<template>
  <span class="w-popconfirm-wrapper">
    <transition name="fade-in-linear">
      <div v-show="showPopper && !disabled" :style="{
        width
      }" :class="['w-popconfirm w-popper', popperClass]" ref="popper">
        <i v-if="showIcon" :class="[icon, 'w-popconfirm__icon']"></i>
        <span v-if="title" v-text="title" class="w-popconfirm__title"></span>
        <div class="w-popconfirm__buttons">
          <w-button size="mini" @click="handleNo">{{cancelText}}</w-button>
          <w-button size="mini" type="primary" @click="handleOk">{{okText}}</w-button>
        </div>
      </div>
    </transition>
    <!-- trigger dom -->
    <slot name="reference"></slot>
  </span>
</template>

<script>
import WButton from '../../button'
import PopperMixin from '../../../mixins/popper'
import {bindEvents, unBindEvents} from '../../../utils/events'
const triggerValidator = (val) => ['hover', 'click'].indexOf(val) > -1
export default {
  name: 'WPopconfirm',
  props: {
    cancelText: {
      type: String,
      default: '取消'
    },
    disabled: Boolean,
    icon: {
      type: String,
      default: 'w-icon-info'
    },
    okText: {
      type: String,
      default: '确定'
    },
    popperClass: String,
    showIcon: {
      type: Boolean,
      default: true
    },
    title: {
      type: String
    },
    trigger: {
      type: String,
      default: 'hover',
      validator: val => triggerValidator(val)
    },
    visibleArrow: {
      type: Boolean,
      default: true
    },
    width: {}
  },
  mixins: [PopperMixin],
  components: {
    WButton
  },
  methods: {
    unBindAllEvents (el) {
      const eventsMap = {
        click: this.togglePopover,
        mousedown: this.showPopover,
        mouseup: this.hiddenPopover,
        mouseenter: this.showPopover,
        mouseleave: this.hiddenPopover
      }
      for (let key in eventsMap) {
        unBindEvents(el, key, eventsMap[key])
      }
      unBindEvents(document, 'click', this.handleDocumentClick)
      unBindEvents(this.$refs.popper, 'mouseenter', this.showPopover)
      unBindEvents(this.$refs.popper, 'mouseleave', this.hiddenPopover)
    },
    handleDocumentClick (e) {
      if (this.referenceElement && this.referenceElement.contains(e.target)) return
      this.hiddenPopover()
    },
    clickTrigger (el) {
      bindEvents(el, 'click', this.togglePopover)
      bindEvents(document, 'click', this.handleDocumentClick)
    },
    hoverTrigger (el) {
      bindEvents(el, 'mouseenter', this.showPopover)
      bindEvents(this.$refs.popper, 'mouseenter', this.showPopover)
      bindEvents(el, 'mouseleave', this.hiddenPopover)
      bindEvents(this.$refs.popper, 'mouseleave', this.hiddenPopover)
    },
    handleOk () {
      this.$emit('confirm')
      this.hiddenPopover()
    },
    handleNo () {
      this.$emit('cancel')
      this.hiddenPopover()
    }
  },
  mounted () {
    const { reference } = this.$slots
    let currentReference = this.referenceElement = reference && reference[0] ? reference[0].elm : this.$refs.reference
    currentReference.classList.add('w-popconfirm__reference')
    switch (this.trigger) {
      case 'click':
        this.clickTrigger(currentReference)
        break
      default:
        this.hoverTrigger(currentReference)
    }
  },
  beforeDestroy () {
    this.unBindAllEvents(this.referenceElement)
  },
  watch: {
    showPopper (val) {
      if (this.disabled) return
      this.$emit(val ? 'show' : 'hidden')
    }
  }
}
</script>

