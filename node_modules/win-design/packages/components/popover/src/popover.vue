<template>
  <span class="popover-wrapper">
    <transition name="fade-in-linear">
      <div v-show="showPopper && !disabled" :style="{
        width
      }" :class="['w-popover w-popper', popperClass, {
        'w-popover--plain': content
      }]" ref="popper">
        <template>
          <span v-if="title" v-text="title" class="w-popover__title"></span>
          <slot name="content">{{ content }}</slot>
          <slot></slot>
        </template>
      </div>
    </transition>
    <slot name="reference"></slot>
  </span>
</template>

<script>
import PopperMixin from '../../../mixins/popper'
import {bindEvents, unBindEvents} from '../../../utils/events'
const triggerValidator = (val) => ['hover', 'click', 'focus', 'manual'].indexOf(val) > -1
export default {
  name: 'WPopover',
  data () {
    return {
    }
  },
  props: {
    content: {
      type: String
    },
    disabled: Boolean,
    popperClass: String,
    reference: {},
    title: {
      type: String
    },
    trigger: {
      type: String,
      default: 'hover',
      validator: val => triggerValidator(val)
    },
    visibleArrow: {
      type: Boolean,
      default: true
    },
    width: {}
  },
  mixins: [PopperMixin],
  methods: {
    unBindAllEvents (el) {
      const eventsMap = {
        click: this.togglePopover,
        focusin: this.showPopover,
        focusout: this.hiddenPopover,
        mousedown: this.showPopover,
        mouseup: this.hiddenPopover,
        mouseenter: this.showPopover,
        mouseleave: this.hiddenPopover
      }
      for (let key in eventsMap) {
        unBindEvents(el, key, eventsMap[key])
      }
      unBindEvents(document, 'click', this.handleDocumentClick)
      unBindEvents(this.$refs.popper, 'mouseenter', this.showPopover)
      unBindEvents(this.$refs.popper, 'mouseleave', this.hiddenPopover)
    },
    handleDocumentClick (e) {
      if (this.referenceElement && this.referenceElement.contains(e.target)) return
      this.showPopper = false
    },
    clickTrigger (el) {
      bindEvents(el, 'click', this.togglePopover)
      bindEvents(document, 'click', this.handleDocumentClick)
    },
    focusTrigger (el) {
      if (el.querySelector('input, textarea')) {
        bindEvents(el, 'focusin', this.showPopover)
        bindEvents(el, 'focusout', this.hiddenPopover)
      } else {
        bindEvents(el, 'mousedown', this.showPopover)
        bindEvents(el, 'mouseup', this.hiddenPopover)
      }
    },
    hoverTrigger (el) {
      bindEvents(el, 'mouseenter', this.showPopover)
      bindEvents(this.$refs.popper, 'mouseenter', this.showPopover)
      bindEvents(el, 'mouseleave', this.hiddenPopover)
      bindEvents(this.$refs.popper, 'mouseleave', this.hiddenPopover)
    },
    focusManual (el) {
      bindEvents(el, 'click', this.togglePopover)
      this.$emit('input', this.showPopper)
    }
  },
  mounted () {
    const { reference } = this.$slots
    let currentReference = this.referenceElement = reference && reference[0]
      ? reference[0].elm
      : this.$refs.reference
    if (!currentReference) return
    currentReference.classList.add('w-popover__reference')
    switch (this.trigger) {
      case 'click':
        this.clickTrigger(currentReference)
        break
      case 'focus':
        this.focusTrigger(currentReference)
        break
      case 'manual':
        this.focusManual(currentReference)
        break
      default:
        this.hoverTrigger(currentReference)
    }
  },
  beforeDestroy () {
    this.unBindAllEvents(this.referenceElement)
  },
  watch: {
    showPopper (val) {
      if (this.disabled) return
      this.$emit(val ? 'show' : 'hidden')
    }
  }
}
</script>
