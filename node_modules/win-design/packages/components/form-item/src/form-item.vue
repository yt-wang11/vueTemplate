<template>
  <div :class="['w-form-item', `is-label-${labelAlign}`, `is-item-${itemSize}`, {
    'is-error': validateStatus === 'error'
  }]">
    <div class="w-form-item__wrapper">
      <label :for="prop" :class="['w-form-item__label', {
        'is-required': showRequiredIcon,
        'is-empty': !label,
        'is-bold': labelBold
      }]" :style="labelStyle">
        <slot name="label">{{label}}</slot>
      </label>
      <div class="w-form-item__main" :style="mainWidth">
        <slot></slot>
        <transition name="fade-in-linear">
          <span v-if="showErrorMessage" v-text="validateMsg"
            class="w-form-item__error"></span>
        </transition>
      </div>
    </div>
  </div>
</template>

<script>
import {getValueByProp, setValueByPath} from '../../../utils/utils'
import Schema from 'async-validator'
import Emitter from '../../../mixins/emitter'
export default {
  name: 'WFormItem',
  data () {
    return {
      parentName: 'WForm',
      validateStatus: '',
      validateMsg: '',
      originalValue: '',
      isValidated: false
    }
  },
  props: {
    showMessage: {
      type: Boolean,
      default: true
    },
    label: String,
    prop: String,
    rules: Array,
    required: Boolean
  },
  provide () {
    return {
      wFormItem: this
    }
  },
  inject: ['wForm'],
  computed: {
    rulesFromForm () {
      if (this.formProps.rules && this.prop) return this.formProps.rules[this.prop]
    },
    formProps () {
      return this.wForm.$props
    },
    inline () {
      return this.formProps.inline
    },
    itemSize () {
      return this.formProps.sizes || 'medium'
    },
    labelBold () {
      return this.formProps.labelBold
    },
    labelWidth () {
      return this.formProps.labelWidth || '0px'
    },
    labelStyle () {
      return this.label ? `width: ${this.labelWidth}`: `margin-left: ${this.inline ? '0px' : `calc(${this.labelWidth} - 12px)`};padding: 0;`
    },
    labelAlign () {
      return this.formProps.labelAlign || 'left'
    },
    mainWidth () {
      if (!this.label && this.inline) return
      return `width: calc(100% - ${this.labelAlign !== 'top' ? this.labelWidth : '0px'})`
    },
    showErrorMessage () {
      return  this.showMessage && this.label && this.validateStatus === 'error'
    },
    showRequiredIcon () {
      if (!this.label) return false
      const rules = this.getRules()
      let isRequired = false
      rules && rules.every(rule => {
        if (rule.required) {
          isRequired = true
          return false
        }
        return true
      })
      return isRequired
    },
    fieldValue () {
      if (this.formProps.model && this.prop) return getValueByProp(this.formProps.model, this.prop)
    }
  },
  mixins: [Emitter],
  methods: {
    getRules (trigger) {
      const selfRules = this.rules || []
      const formRules = this.rulesFromForm || []
      const isRequired = this.required !== undefined ? [{
        required: this.required
      }] : []
      const rules = [...selfRules, ...formRules, ...isRequired]
      return trigger ? this.filterRules(trigger, rules) : rules
    },
    filterRules (filter, rules) {
      return rules.filter(({trigger}) => Array.isArray(trigger)
        ? trigger.includes(filter)
        : filter === trigger)
    },
    resetField () {
      this.validateStatus = ''
      this.validateMsg = ''
      this.isValidated = false
      setValueByPath(this.formProps.model, this.prop, this.originalValue)
    },
    validateField (trigger, cb = () => {}) {
      this.isValidated = true
      const rules = this.getRules(trigger)
      // 无需验证
      if (!rules.length || rules.length === 1 && !rules[0].required) {
        cb()
        return true
      }
      // 验证
      const validator = new Schema({
        [this.prop]: rules
      })
      validator.validate({
        [this.prop]: this.fieldValue
      }, {
        firstFields: true
      }, (errors, invalidFields) => {
        this.validateStatus = errors ? 'error' : 'success'
        this.validateMsg = errors ? errors[0].message : ''
        cb(this.validateMsg, invalidFields)
      })
    },
    handleFieldBlur () {
      // if (this.isValidated) {
      //   this.isValidated = false
      //   return
      // }
      this.validateField('blur')
    },
    handleFieldChange () {
      this.validateField('change')
    },
    bindEvents () {
      this.$on('w.form.field.blur', this.handleFieldBlur)
      this.$on('w.form.field.change', this.handleFieldChange)
    }
  },
  mounted () {
    if (this.prop) {
      this.originalValue = this.fieldValue
      this.dispatchEvent(this.parentName, 'addField', [this])
      // bind events
      this.bindEvents()
    }
  },
  beforeDestroy () {
    this.prop && this.dispatchEvent(this.parentName, 'removeField', [this])
  }
}
</script>
