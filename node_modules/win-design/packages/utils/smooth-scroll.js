const isClient = () => {
  return typeof window !== 'undefined'
}
isClient() && (window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFram || window.webkitRequestAnimationFrame)

const DefaultDuration = 450 // 默认持续时间
const QuadEaseIn = (t, b, c, d) => {
  /**
   * 缓动函数
   * Tween.js
   * @param {Number} t current time 当前时间
   * @param {Number} b beginning value 初始值
   * @param {Number} c change in value 变化量
   * @param {Number} d duration 持续时间
   */
  return c * ((t = t / d - 1) * t * t + 1) + b
}

export const scrollTo = (to, duration = DefaultDuration, getContainer = () => window) => {
  /**
   * 滚动到具体位置
   * @param {Number} to 滚动到某个位置
   * @param {Number} duration 动画时间
   * @param {Object} container 容器DOM 默认window
   */
  const container = getContainer()
  let b = container === window
    ? isClient() && window.pageYOffset !== undefined
      ? window.pageYOffset
      : document.documentElement.scrollTop
    : container.scrollTop // 初始值
  let c = to - b
  let d = duration
  let start = null

  const setScrollTop = (val) => {
    if (isClient() && container === window) {
      document.body.scrollTop = val
      document.documentElement.scrollTop = val
    } else {
      container.scrollTop = val
    }
  }
  return new Promise((resolve, reject) => {
    const step = (timeStamp) => {
      start === null && (start = timeStamp)
      let t = timeStamp - start
      if (t < duration) {
        let st = QuadEaseIn(t, b, c, d)
        setScrollTop(st)
        isClient() && window.requestAnimationFrame(step)
      } else {
        setScrollTop(to)
        resolve()
      }
    }
    isClient() && window.requestAnimationFrame(step)
  })
}

export const scrollToTop = (duration, container) => {
  /**
   * 滚动到顶部
   * @param {Number} duration 动画时间
   * @param {Object} container 容器DOM 默认window
   */
  return scrollTo(0, typeof duration === 'number' ? duration : DefaultDuration, container)
}

export const getOffsetTop = (target, getContainer) => {
  /**
   * 获取目标元素与container顶部之间的offsetTop
   * @param {DOM} target 需要定位到到元素
   * @param {Object} container 容器DOM 默认window
   */
  const container = getContainer()
  const clientRect = target.getBoundingClientRect()
  if (!target) return 0
  if (container === window) {
    return clientRect.top + (window.pageYOffset || document.documentElement.scrollTop) - (document.documentElement.clientTop || 0)
  } else {
    return clientRect.top + container.scrollTop - container.getBoundingClientRect().top
  }
}

export const scrollToElement = (target, getContainer = () => window, duration, offset = 0) => {
  /**
   * @param {DOM} target 需要定位到到元素
   * @param {Number} duration 持续时间
   * @param {Number} offset 偏移量
   */
  if (!target) return
  return scrollTo(getOffsetTop(target, getContainer) - offset, duration, getContainer)
}

export default {
  getOffsetTop,
  scrollTo,
  scrollToTop,
  scrollToElement
}
